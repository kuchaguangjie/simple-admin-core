// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/redis/go-redis/v9"
	"github.com/suyuan32/simple-admin-core/rpc/ent/predicate"
)

// GetCache returns a API entity by its id, use cache if it exists.
func (aq *APIQuery) GetCache(ctx context.Context, rds *redis.Client, predicates predicate.API, keyVal string, expire time.Duration) (*API, error) {
	var key strings.Builder
	key.WriteString("DB:CACHE:API:")
	key.WriteString(keyVal)

	cacheData, err := rds.Get(ctx, key.String()).Result()

	if errors.Is(err, redis.Nil) {
		data, err := aq.Where(predicates).Only(ctx)
		if err != nil {
			return nil, err
		}

		m, err := json.Marshal(data)
		if err != nil {
			return nil, err
		}

		err = rds.Set(ctx, key.String(), m, expire).Err()
		if err != nil {
			return nil, err
		}

		return data, err
	} else if err != nil {
		return nil, err
	}

	result := &API{}

	err = json.Unmarshal([]byte(cacheData), result)
	if err != nil {
		return nil, err
	}

	return result, err
}

// DelCache delete the API redis cache of specific key
func (aq *APIQuery) DelCache(ctx context.Context, rds *redis.Client, keyVal string) error {
	var key strings.Builder
	key.WriteString("DB:CACHE:API:")
	key.WriteString(keyVal)

	err := rds.Del(ctx, key.String()).Err()
	if err != nil {
		return err
	}

	return err
}

// GetCache returns a Department entity by its id, use cache if it exists.
func (dq *DepartmentQuery) GetCache(ctx context.Context, rds *redis.Client, predicates predicate.Department, keyVal string, expire time.Duration) (*Department, error) {
	var key strings.Builder
	key.WriteString("DB:CACHE:Department:")
	key.WriteString(keyVal)

	cacheData, err := rds.Get(ctx, key.String()).Result()

	if errors.Is(err, redis.Nil) {
		data, err := dq.Where(predicates).Only(ctx)
		if err != nil {
			return nil, err
		}

		m, err := json.Marshal(data)
		if err != nil {
			return nil, err
		}

		err = rds.Set(ctx, key.String(), m, expire).Err()
		if err != nil {
			return nil, err
		}

		return data, err
	} else if err != nil {
		return nil, err
	}

	result := &Department{}

	err = json.Unmarshal([]byte(cacheData), result)
	if err != nil {
		return nil, err
	}

	return result, err
}

// DelCache delete the Department redis cache of specific key
func (dq *DepartmentQuery) DelCache(ctx context.Context, rds *redis.Client, keyVal string) error {
	var key strings.Builder
	key.WriteString("DB:CACHE:Department:")
	key.WriteString(keyVal)

	err := rds.Del(ctx, key.String()).Err()
	if err != nil {
		return err
	}

	return err
}

// GetCache returns a Dictionary entity by its id, use cache if it exists.
func (dq *DictionaryQuery) GetCache(ctx context.Context, rds *redis.Client, predicates predicate.Dictionary, keyVal string, expire time.Duration) (*Dictionary, error) {
	var key strings.Builder
	key.WriteString("DB:CACHE:Dictionary:")
	key.WriteString(keyVal)

	cacheData, err := rds.Get(ctx, key.String()).Result()

	if errors.Is(err, redis.Nil) {
		data, err := dq.Where(predicates).Only(ctx)
		if err != nil {
			return nil, err
		}

		m, err := json.Marshal(data)
		if err != nil {
			return nil, err
		}

		err = rds.Set(ctx, key.String(), m, expire).Err()
		if err != nil {
			return nil, err
		}

		return data, err
	} else if err != nil {
		return nil, err
	}

	result := &Dictionary{}

	err = json.Unmarshal([]byte(cacheData), result)
	if err != nil {
		return nil, err
	}

	return result, err
}

// DelCache delete the Dictionary redis cache of specific key
func (dq *DictionaryQuery) DelCache(ctx context.Context, rds *redis.Client, keyVal string) error {
	var key strings.Builder
	key.WriteString("DB:CACHE:Dictionary:")
	key.WriteString(keyVal)

	err := rds.Del(ctx, key.String()).Err()
	if err != nil {
		return err
	}

	return err
}

// GetCache returns a DictionaryDetail entity by its id, use cache if it exists.
func (ddq *DictionaryDetailQuery) GetCache(ctx context.Context, rds *redis.Client, predicates predicate.DictionaryDetail, keyVal string, expire time.Duration) (*DictionaryDetail, error) {
	var key strings.Builder
	key.WriteString("DB:CACHE:DictionaryDetail:")
	key.WriteString(keyVal)

	cacheData, err := rds.Get(ctx, key.String()).Result()

	if errors.Is(err, redis.Nil) {
		data, err := ddq.Where(predicates).Only(ctx)
		if err != nil {
			return nil, err
		}

		m, err := json.Marshal(data)
		if err != nil {
			return nil, err
		}

		err = rds.Set(ctx, key.String(), m, expire).Err()
		if err != nil {
			return nil, err
		}

		return data, err
	} else if err != nil {
		return nil, err
	}

	result := &DictionaryDetail{}

	err = json.Unmarshal([]byte(cacheData), result)
	if err != nil {
		return nil, err
	}

	return result, err
}

// DelCache delete the DictionaryDetail redis cache of specific key
func (ddq *DictionaryDetailQuery) DelCache(ctx context.Context, rds *redis.Client, keyVal string) error {
	var key strings.Builder
	key.WriteString("DB:CACHE:DictionaryDetail:")
	key.WriteString(keyVal)

	err := rds.Del(ctx, key.String()).Err()
	if err != nil {
		return err
	}

	return err
}

// GetCache returns a Menu entity by its id, use cache if it exists.
func (mq *MenuQuery) GetCache(ctx context.Context, rds *redis.Client, predicates predicate.Menu, keyVal string, expire time.Duration) (*Menu, error) {
	var key strings.Builder
	key.WriteString("DB:CACHE:Menu:")
	key.WriteString(keyVal)

	cacheData, err := rds.Get(ctx, key.String()).Result()

	if errors.Is(err, redis.Nil) {
		data, err := mq.Where(predicates).Only(ctx)
		if err != nil {
			return nil, err
		}

		m, err := json.Marshal(data)
		if err != nil {
			return nil, err
		}

		err = rds.Set(ctx, key.String(), m, expire).Err()
		if err != nil {
			return nil, err
		}

		return data, err
	} else if err != nil {
		return nil, err
	}

	result := &Menu{}

	err = json.Unmarshal([]byte(cacheData), result)
	if err != nil {
		return nil, err
	}

	return result, err
}

// DelCache delete the Menu redis cache of specific key
func (mq *MenuQuery) DelCache(ctx context.Context, rds *redis.Client, keyVal string) error {
	var key strings.Builder
	key.WriteString("DB:CACHE:Menu:")
	key.WriteString(keyVal)

	err := rds.Del(ctx, key.String()).Err()
	if err != nil {
		return err
	}

	return err
}

// GetCache returns a OauthProvider entity by its id, use cache if it exists.
func (opq *OauthProviderQuery) GetCache(ctx context.Context, rds *redis.Client, predicates predicate.OauthProvider, keyVal string, expire time.Duration) (*OauthProvider, error) {
	var key strings.Builder
	key.WriteString("DB:CACHE:OauthProvider:")
	key.WriteString(keyVal)

	cacheData, err := rds.Get(ctx, key.String()).Result()

	if errors.Is(err, redis.Nil) {
		data, err := opq.Where(predicates).Only(ctx)
		if err != nil {
			return nil, err
		}

		m, err := json.Marshal(data)
		if err != nil {
			return nil, err
		}

		err = rds.Set(ctx, key.String(), m, expire).Err()
		if err != nil {
			return nil, err
		}

		return data, err
	} else if err != nil {
		return nil, err
	}

	result := &OauthProvider{}

	err = json.Unmarshal([]byte(cacheData), result)
	if err != nil {
		return nil, err
	}

	return result, err
}

// DelCache delete the OauthProvider redis cache of specific key
func (opq *OauthProviderQuery) DelCache(ctx context.Context, rds *redis.Client, keyVal string) error {
	var key strings.Builder
	key.WriteString("DB:CACHE:OauthProvider:")
	key.WriteString(keyVal)

	err := rds.Del(ctx, key.String()).Err()
	if err != nil {
		return err
	}

	return err
}

// GetCache returns a Position entity by its id, use cache if it exists.
func (pq *PositionQuery) GetCache(ctx context.Context, rds *redis.Client, predicates predicate.Position, keyVal string, expire time.Duration) (*Position, error) {
	var key strings.Builder
	key.WriteString("DB:CACHE:Position:")
	key.WriteString(keyVal)

	cacheData, err := rds.Get(ctx, key.String()).Result()

	if errors.Is(err, redis.Nil) {
		data, err := pq.Where(predicates).Only(ctx)
		if err != nil {
			return nil, err
		}

		m, err := json.Marshal(data)
		if err != nil {
			return nil, err
		}

		err = rds.Set(ctx, key.String(), m, expire).Err()
		if err != nil {
			return nil, err
		}

		return data, err
	} else if err != nil {
		return nil, err
	}

	result := &Position{}

	err = json.Unmarshal([]byte(cacheData), result)
	if err != nil {
		return nil, err
	}

	return result, err
}

// DelCache delete the Position redis cache of specific key
func (pq *PositionQuery) DelCache(ctx context.Context, rds *redis.Client, keyVal string) error {
	var key strings.Builder
	key.WriteString("DB:CACHE:Position:")
	key.WriteString(keyVal)

	err := rds.Del(ctx, key.String()).Err()
	if err != nil {
		return err
	}

	return err
}

// GetCache returns a Role entity by its id, use cache if it exists.
func (rq *RoleQuery) GetCache(ctx context.Context, rds *redis.Client, predicates predicate.Role, keyVal string, expire time.Duration) (*Role, error) {
	var key strings.Builder
	key.WriteString("DB:CACHE:Role:")
	key.WriteString(keyVal)

	cacheData, err := rds.Get(ctx, key.String()).Result()

	if errors.Is(err, redis.Nil) {
		data, err := rq.Where(predicates).Only(ctx)
		if err != nil {
			return nil, err
		}

		m, err := json.Marshal(data)
		if err != nil {
			return nil, err
		}

		err = rds.Set(ctx, key.String(), m, expire).Err()
		if err != nil {
			return nil, err
		}

		return data, err
	} else if err != nil {
		return nil, err
	}

	result := &Role{}

	err = json.Unmarshal([]byte(cacheData), result)
	if err != nil {
		return nil, err
	}

	return result, err
}

// DelCache delete the Role redis cache of specific key
func (rq *RoleQuery) DelCache(ctx context.Context, rds *redis.Client, keyVal string) error {
	var key strings.Builder
	key.WriteString("DB:CACHE:Role:")
	key.WriteString(keyVal)

	err := rds.Del(ctx, key.String()).Err()
	if err != nil {
		return err
	}

	return err
}

// GetCache returns a Token entity by its id, use cache if it exists.
func (tq *TokenQuery) GetCache(ctx context.Context, rds *redis.Client, predicates predicate.Token, keyVal string, expire time.Duration) (*Token, error) {
	var key strings.Builder
	key.WriteString("DB:CACHE:Token:")
	key.WriteString(keyVal)

	cacheData, err := rds.Get(ctx, key.String()).Result()

	if errors.Is(err, redis.Nil) {
		data, err := tq.Where(predicates).Only(ctx)
		if err != nil {
			return nil, err
		}

		m, err := json.Marshal(data)
		if err != nil {
			return nil, err
		}

		err = rds.Set(ctx, key.String(), m, expire).Err()
		if err != nil {
			return nil, err
		}

		return data, err
	} else if err != nil {
		return nil, err
	}

	result := &Token{}

	err = json.Unmarshal([]byte(cacheData), result)
	if err != nil {
		return nil, err
	}

	return result, err
}

// DelCache delete the Token redis cache of specific key
func (tq *TokenQuery) DelCache(ctx context.Context, rds *redis.Client, keyVal string) error {
	var key strings.Builder
	key.WriteString("DB:CACHE:Token:")
	key.WriteString(keyVal)

	err := rds.Del(ctx, key.String()).Err()
	if err != nil {
		return err
	}

	return err
}

// GetCache returns a User entity by its id, use cache if it exists.
func (uq *UserQuery) GetCache(ctx context.Context, rds *redis.Client, predicates predicate.User, keyVal string, expire time.Duration) (*User, error) {
	var key strings.Builder
	key.WriteString("DB:CACHE:User:")
	key.WriteString(keyVal)

	cacheData, err := rds.Get(ctx, key.String()).Result()

	if errors.Is(err, redis.Nil) {
		data, err := uq.Where(predicates).Only(ctx)
		if err != nil {
			return nil, err
		}

		m, err := json.Marshal(data)
		if err != nil {
			return nil, err
		}

		err = rds.Set(ctx, key.String(), m, expire).Err()
		if err != nil {
			return nil, err
		}

		return data, err
	} else if err != nil {
		return nil, err
	}

	result := &User{}

	err = json.Unmarshal([]byte(cacheData), result)
	if err != nil {
		return nil, err
	}

	return result, err
}

// DelCache delete the User redis cache of specific key
func (uq *UserQuery) DelCache(ctx context.Context, rds *redis.Client, keyVal string) error {
	var key strings.Builder
	key.WriteString("DB:CACHE:User:")
	key.WriteString(keyVal)

	err := rds.Del(ctx, key.String()).Err()
	if err != nil {
		return err
	}

	return err
}
